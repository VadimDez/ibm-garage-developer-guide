{"componentChunkName":"component---src-pages-guides-continuous-integration-tekton-index-mdx","path":"/guides/continuous-integration-tekton/","result":{"pageContext":{"isCreatedByStatefulCreatePages":true,"frontmatter":{"title":"Continuous Integration with Tekton","description":"This guide will explain how to use Tekton to manage your Continuous Integration process"},"relativePagePath":"/guides/continuous-integration-tekton/index.mdx","titleType":"page","MdxNode":{"id":"d60325cf-3e20-5ab5-a494-dd7c3b1c4605","children":[],"parent":"276ff152-9e6e-598c-b08e-914c3a2c5508","internal":{"content":"---\ntitle: Continuous Integration with Tekton\ndescription: This guide will explain how to use Tekton to manage your Continuous Integration process\n---\n\n### Overview\n\n\n### Tekton\n\n\n\n\n### Pipelines\n\nPipelines offer a set of stages or steps that can be chained together to allow a level of software\nautomation. This automation can be tailored to the specific project requirements.\n\n\n\n\n\n### Stages\n\nYou can see from either the vanilla Jenkins pipelines view of the Application Console pipelines view, each template offers a number of pipeline stages. The stages have been configured to be work from the defined `secrets` and `config maps` that have been defined in the Development cluster setup.\n\nThe following gives a description of what each stage in the pipeline does. The *Optional* stages can be deleted or ignored if the tool support it is not installed. These stages represent a typical production pipeline flow for a Cloud Native application.\n\n- **Setup** clones the code into the pipeline\n- **Build** runs the build commands for the code\n- **Test**\tvalidates the unit tests for the code\n- **Publish pacts**\t(*optional*) publishes any pact contracts that have been defined\n- **Verify pact** (*optional*) verifies the pact contracts\n- **Sonar scan** (*optional*) runs a sonar code scan of the source code and publishes the results to SonarQube\n- **Verify environment** Validates the OpenShift or IKS environment configuration is valid\n- **Build image** Builds the code into a Docker images and stores it in the IBM Cloud Image registry\n- **Deploy to DEV env**\tDeploys the Docker image tagged version to `dev` namespace using Helm Chart\n- **Health Check** Validates the Health Endpoint of the deployed application\n- **Package Helm Chart** (*optional*) Stores the tagged version of the Helm chart into Artifactory\n- **Trigger CD Pipeline** (*optional*) This is a GitOps stage that will update the build number in designated git repo and trigger ArgoCD for deployment to **test**\n\n## Registering Pipelines\n\n\nOnce you become familiar with deploying code into OpenShift or IKS, read up about how you can manage code deployment with `Continuous Deployment` with `Artiactory` and `ArgoCD`\n\n- [Artiact Storage with Artifactory](./ARTIFACTORY.md)\n- [Continuous Deployment with ArgoCD](./ARGOCD.md)\n\nYou can use the [Argo CD Template](https://github.com/ibm-garage-cloud/template-argocd-test) to help define a deployment configuration for `test` and `staging` namespaces.\n\n\n\n","type":"Mdx","contentDigest":"fa4f22222ed0e5b8bbeedacd41824382","counter":277,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Continuous Integration with Tekton","description":"This guide will explain how to use Tekton to manage your Continuous Integration process"},"exports":{},"rawBody":"---\ntitle: Continuous Integration with Tekton\ndescription: This guide will explain how to use Tekton to manage your Continuous Integration process\n---\n\n### Overview\n\n\n### Tekton\n\n\n\n\n### Pipelines\n\nPipelines offer a set of stages or steps that can be chained together to allow a level of software\nautomation. This automation can be tailored to the specific project requirements.\n\n\n\n\n\n### Stages\n\nYou can see from either the vanilla Jenkins pipelines view of the Application Console pipelines view, each template offers a number of pipeline stages. The stages have been configured to be work from the defined `secrets` and `config maps` that have been defined in the Development cluster setup.\n\nThe following gives a description of what each stage in the pipeline does. The *Optional* stages can be deleted or ignored if the tool support it is not installed. These stages represent a typical production pipeline flow for a Cloud Native application.\n\n- **Setup** clones the code into the pipeline\n- **Build** runs the build commands for the code\n- **Test**\tvalidates the unit tests for the code\n- **Publish pacts**\t(*optional*) publishes any pact contracts that have been defined\n- **Verify pact** (*optional*) verifies the pact contracts\n- **Sonar scan** (*optional*) runs a sonar code scan of the source code and publishes the results to SonarQube\n- **Verify environment** Validates the OpenShift or IKS environment configuration is valid\n- **Build image** Builds the code into a Docker images and stores it in the IBM Cloud Image registry\n- **Deploy to DEV env**\tDeploys the Docker image tagged version to `dev` namespace using Helm Chart\n- **Health Check** Validates the Health Endpoint of the deployed application\n- **Package Helm Chart** (*optional*) Stores the tagged version of the Helm chart into Artifactory\n- **Trigger CD Pipeline** (*optional*) This is a GitOps stage that will update the build number in designated git repo and trigger ArgoCD for deployment to **test**\n\n## Registering Pipelines\n\n\nOnce you become familiar with deploying code into OpenShift or IKS, read up about how you can manage code deployment with `Continuous Deployment` with `Artiactory` and `ArgoCD`\n\n- [Artiact Storage with Artifactory](./ARTIFACTORY.md)\n- [Continuous Deployment with ArgoCD](./ARGOCD.md)\n\nYou can use the [Argo CD Template](https://github.com/ibm-garage-cloud/template-argocd-test) to help define a deployment configuration for `test` and `staging` namespaces.\n\n\n\n","fileAbsolutePath":"/Users/seansund/ws/catalyst/garage-developer-guide/src/pages/guides/continuous-integration-tekton/index.mdx"}}}}