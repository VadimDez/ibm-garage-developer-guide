{"componentChunkName":"component---src-pages-guides-continuous-integration-tekton-index-mdx","path":"/guides/continuous-integration-tekton/","result":{"pageContext":{"isCreatedByStatefulCreatePages":true,"frontmatter":{"title":"Continuous Integration with Tekton","description":"This guide will explain how to use Tekton to manage your Continuous Integration process"},"relativePagePath":"/guides/continuous-integration-tekton/index.mdx","titleType":"page","MdxNode":{"id":"3e052ab8-4089-5e90-b018-a5774e9c7176","children":[],"parent":"59d80ee0-36e6-5802-a108-d7ec1c2ee570","internal":{"content":"---\ntitle: Continuous Integration with Tekton\ndescription: This guide will explain how to use Tekton to manage your Continuous Integration process\n---\n\n### Overview\n\n\n### Tekton\n\n\n\n\n### Pipelines\n\nPipelines offer a set of stages or steps that can be chained together to allow a level of software\nautomation. This automation can be tailored to the specific project requirements.\n\n\n\n\n\n### Stages\n\nYou can see from either the vanilla Jenkins pipelines view of the Application Console pipelines view, each template offers a number of pipeline stages. The stages have been configured to be work from the defined `secrets` and `config maps` that have been defined in the Development cluster setup.\n\nThe following gives a description of what each stage in the pipeline does. The *Optional* stages can be deleted or ignored if the tool support it is not installed. These stages represent a typical production pipeline flow for a Cloud Native application.\n\n- **Setup** clones the code into the pipeline\n- **Build** runs the build commands for the code\n- **Test**\tvalidates the unit tests for the code\n- **Publish pacts**\t(*optional*) publishes any pact contracts that have been defined\n- **Verify pact** (*optional*) verifies the pact contracts\n- **Sonar scan** (*optional*) runs a sonar code scan of the source code and publishes the results to SonarQube\n- **Verify environment** Validates the OpenShift or IKS environment configuration is valid\n- **Build image** Builds the code into a Docker images and stores it in the IBM Cloud Image registry\n- **Deploy to DEV env**\tDeploys the Docker image tagged version to `dev` namespace using Helm Chart\n- **Health Check** Validates the Health Endpoint of the deployed application\n- **Package Helm Chart** (*optional*) Stores the tagged version of the Helm chart into Artifactory\n- **Trigger CD Pipeline** (*optional*) This is a GitOps stage that will update the build number in designated git repo and trigger ArgoCD for deployment to **test**\n\n## Registering Pipelines\n\n\nOnce you become familiar with deploying code into OpenShift or IKS, read up about how you can manage code deployment with `Continuous Deployment` with `Artiactory` and `ArgoCD`\n\n- [Artiact Storage with Artifactory](./ARTIFACTORY.md)\n- [Continuous Deployment with ArgoCD](./ARGOCD.md)\n\nYou can use the [Argo CD Template](https://github.com/ibm-garage-cloud/template-argocd-test) to help define a deployment configuration for `test` and `staging` namespaces.\n\n\n\n","type":"Mdx","contentDigest":"23ab9ed7ec2500e04adfa24e90f8099f","counter":424,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Continuous Integration with Tekton","description":"This guide will explain how to use Tekton to manage your Continuous Integration process"},"exports":{},"rawBody":"---\ntitle: Continuous Integration with Tekton\ndescription: This guide will explain how to use Tekton to manage your Continuous Integration process\n---\n\n### Overview\n\n\n### Tekton\n\n\n\n\n### Pipelines\n\nPipelines offer a set of stages or steps that can be chained together to allow a level of software\nautomation. This automation can be tailored to the specific project requirements.\n\n\n\n\n\n### Stages\n\nYou can see from either the vanilla Jenkins pipelines view of the Application Console pipelines view, each template offers a number of pipeline stages. The stages have been configured to be work from the defined `secrets` and `config maps` that have been defined in the Development cluster setup.\n\nThe following gives a description of what each stage in the pipeline does. The *Optional* stages can be deleted or ignored if the tool support it is not installed. These stages represent a typical production pipeline flow for a Cloud Native application.\n\n- **Setup** clones the code into the pipeline\n- **Build** runs the build commands for the code\n- **Test**\tvalidates the unit tests for the code\n- **Publish pacts**\t(*optional*) publishes any pact contracts that have been defined\n- **Verify pact** (*optional*) verifies the pact contracts\n- **Sonar scan** (*optional*) runs a sonar code scan of the source code and publishes the results to SonarQube\n- **Verify environment** Validates the OpenShift or IKS environment configuration is valid\n- **Build image** Builds the code into a Docker images and stores it in the IBM Cloud Image registry\n- **Deploy to DEV env**\tDeploys the Docker image tagged version to `dev` namespace using Helm Chart\n- **Health Check** Validates the Health Endpoint of the deployed application\n- **Package Helm Chart** (*optional*) Stores the tagged version of the Helm chart into Artifactory\n- **Trigger CD Pipeline** (*optional*) This is a GitOps stage that will update the build number in designated git repo and trigger ArgoCD for deployment to **test**\n\n## Registering Pipelines\n\n\nOnce you become familiar with deploying code into OpenShift or IKS, read up about how you can manage code deployment with `Continuous Deployment` with `Artiactory` and `ArgoCD`\n\n- [Artiact Storage with Artifactory](./ARTIFACTORY.md)\n- [Continuous Deployment with ArgoCD](./ARGOCD.md)\n\nYou can use the [Argo CD Template](https://github.com/ibm-garage-cloud/template-argocd-test) to help define a deployment configuration for `test` and `staging` namespaces.\n\n\n\n","fileAbsolutePath":"/Users/bwoolf/dev/git/ibm-garage-cloud/ibm-garage-developer-guide/src/pages/guides/continuous-integration-tekton/index.mdx"}}}}