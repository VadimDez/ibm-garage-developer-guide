{"componentChunkName":"component---src-pages-contributing-index-mdx","path":"/contributing/","result":{"pageContext":{"isCreatedByStatefulCreatePages":true,"frontmatter":{"title":"Contributing"},"relativePagePath":"/contributing/index.mdx","titleType":"page","MdxNode":{"id":"2ffa8863-2037-50fb-9d1f-84d0d77f2e68","children":[],"parent":"65fa5f52-83b6-5cd1-8b7c-60c802f293f4","internal":{"content":"---\ntitle: Contributing\n---\n\n## IBM Garage for Cloud Developer Tools\n\n_IBM Garage for Cloud Developer Tools_  is an organized effort managed by IBM Cloud Garage to help development teams build and deliver cloud-native solutions deployed to IBM Cloud with IBM Kubernetes and Red Hat OpenShift Managed Service .\n\n### Developer assets\n\n_Developer Tools assets_ (aka assets) are guidelines, components, and tooling, the result of community contributions of code, design, ideas, and guidance, that have been packaged and shared for reuse on development projects. Their purpose is twofold:\n- Increase the productivity of application developers\n- Increase the consistency of applications that are developed\n- Drive adoption of Kubernetes and OpenShift usage\n\nAssets will embody best practices for common application architectures, implementations, and development tasks and make those best practices easier to apply. Assets will be managed and made available for use via projects.\n\n###  Projects\n\n_Developer Tools projects_ (aka projects) are open source efforts narrowly focused on specific areas of interest. The assets are divided into projects. A project should organize a set of related assets such that a user or contributor interested in a project should be interested in  all of the assets in a project.\n\nEach project will store its assets in a GitHub repository to facilitate managing development of the assets as well as helping individual development projects to access and apply the assets.\n\n## Roles and responsibilities\n\n### Consumers\n\n_Consumers_ are members of the community who are applying assets to their development projects. Anyone who wants to apply any of the assets can be a user. We encourage consumers to participate as evangelists and contributors as well.\n\n### Evangelists\n\n_Evangelists_ are members of the community who help others become consumers of the assets. They do so by:\n- Advertising the assets and encouraging others to use them\n- Supporting new consumers and answering questions, such as on Slack (IBM internal)\n- Reporting bugs or missing features through GitHub issues\n\n### Contributors\n\n_Contributors_ are members of the community who help maintain, improve, and expand the assets. In addition to using and evangelizing the assets, they make the assets better by:\n- Resolving issues in GitHub to fix bugs, add features, and improve documentation\n- Submitting changes as GitHub pull requests\n\n### Maintainers\n\n_Project maintainers_ (aka maintainers) are owners of the project who are committed to the success of the assets in that project. Each project has a team of maintainers, and each team has a lead. In addition to their participation as contributors, maintainers have privileges to:\n- Label, close, and manage GitHub issues\n- Close and merge GitHub pull requests\n- Nominate and vote on new maintainers\n\n## Types of teams\n\n### Core team\n\nCore team members are IBM employees responsible for the leadership and strategic direction of the set of Catalyst projects as a whole. The core team also directs how the Catalyst strategy will evolve with IBM Cloud product decisions. Core team responsibilities include:\n\n- Actively engaging with the projects' communities\n- Setting overall direction and vision\n- Setting priorities and release schedule\n- Focusing on broad, cross-cutting concerns\n- Spinning up or shutting down project teams\n\nThe core team will operate the technical steering committee.\n\n#### Technical steering committee\n\nThe technical steering committee coordinates the project teams to ensure consistency between the projects and fosters collaboration between the core team and each project team. This close communication on cross-cutting concerns greatly mitigates the risk of misalignment that can come from decentralized efforts. The committee consists of the project leads of all of the projects as well as other members of the core team who may not presently be leading any projects.\n\n### Project teams\n\nEach project team maintains the assets in its project. Therefore, its members are the maintainers of the assets. Each project operates independently, though it should follow this governance structure to define roles, responsibilities, and decision-making protocols.\n\nThe project has a project lead, a lead maintainer who should also be a member of the [technical steering committee](#technical-steering-committee).\n\nEach project lead is responsible for:\n- Acting as a point of primary contact for the team\n- Participating in the technical steering committee\n- Deciding on the initial membership of project maintainers (in consultation with the core team)\n- Determining and publishing project team policies and mechanics, including the way maintainers join and leave the team (which should be based on team consensus)\n- Communicating core vision to the team\n- Ensuring that issues and pull requests progress at a reasonable rate\n- Making final decisions in cases where the team is unable to reach consensus (should be rare)\n\nThe way that project teams communicate internally and externally is left to each team, but:\n- Technical discussion should take place in the public domain as much as possible, ideally in GitHub issues and pull requests.\n- Each project should have a dedicated Slack channel (IBM internal). Decisions from Slack discussions should be captured in GitHub issues.\n- Project teams should actively seek out discussion and input from stakeholders who are not members of the team.\n\n## Governance\n\n### Planning\n\nProject planning is managed in a [Kanban board](https://en.wikipedia.org/wiki/Kanban_board), specifically this Zenhub board:\n\n- [Planning Zenhub](https://github.ibm.com/garage-catalyst/planning) (To Be Moved Externally)\n\n### Decision-making\n\nProject teams should use [consensus decision making](#consensus) as much as possible, but resort to [lack of consensus decision making](#lack-of-consensus) when necessary.\n\n#### Consensus\n\nProject teams use [consensus decision-making](http://en.wikipedia.org/wiki/Consensus_decision-making) with the premise that a successful outcome is not where one side of a debate has \"won,\" but rather where concerns from _all_ sides have been addressed in some way. **This emphatically does not mean design by committee, nor compromised design.** Rather, it's a recognition that every design or implementation choice carries a trade-off and numerous costs. There is seldom a 100% right answer.\n\nBreakthrough thinking sometimes end up changing the playing field by eliminating tradeoffs altogether, but more often, difficult decisions have to be made. **The key is to have a clear vision and set of values and priorities**, which is the core team's responsibility to set and communicate, and the project teams' responsibility to act upon.\n\nWhenever possible, seek to reach consensus through discussion and design iteration. Concretely, the steps are:\n\n- New GitHub issue or pull request is created with initial analysis of tradeoffs.\n- Comments reveal additional drawbacks, problems, or tradeoffs.\n- The issue or pull request is revised to address comments, often by improving the design or implementation.\n- Repeat above until \"major objections\" are fully addressed, or it's clear that there is a fundamental choice to be made.\n\nConsensus is reached when most people are left with only \"minor\" objections. While they might choose the tradeoffs slightly differently, they do not feel a strong need to _actively block_ the issue or pull request from progressing.\n\nOne important question is: consensus among which people, exactly? Of course, the broader the consensus, the better. When a decision in a project team affects other teams (e.g. new/changed API), the team will be encouraged to invite people (e.g. leads) from affected teams. But at the very least, **consensus within the members of the project team should be the norm for most decisions**. If the core team has done its job of communicating the values and priorities, it should be possible to fit the debate about the issue into that framework and reach a fairly clear outcome.\n\n#### Lack of consensus\n\nIn some cases, though, consensus cannot be reached. These cases tend to split into two very different camps:\n\n- **\"Trivial\" reasons**, e.g., there is not widespread agreement about naming, but there is consensus about the substance.\n- **\"Deep\" reasons**, e.g., the design fundamentally improves one set of concerns at the expense of another, and people on both sides feel strongly about it.\n\nIn either case, an alternative form of decision-making is needed.\n\n- For the \"trivial\" case, the project lead will make an executive decision or defer the decision to another maintainer on the team.\n- For the \"deep\" case, the project lead is empowered to make a final decision, but should consult with the core team before doing so.\n\n### Contribution process\n\nCatalyst assets are typically stored in GitHub repositories and use a [fork and pull request](https://guides.github.com/activities/forking/) workflow for contributions. Specific instructions can be found in each project's GitHub `CONTRIBUTING.md` file.\n\n### Contributor License Agreement\n\nWe require contributors outside of IBM to sign our Contributor License Agreement (CLA) before code contributions can be reviewed and merged. If you have questions, please [contact the core team](/help/support#email).\n\n### Support\n\nHave questions? Found a bug? Learn where to go and what to do by visiting the [Support page](/help/support).\n\n## Contributing\n\n## Requirements\n\nSet up your SSH Key GitHub account and install node.js 4 or higher.\n\n- [Generating SSH Keys - GitHub](https://help.github.com/articles/generating-ssh-keys/)\n- [`nvm` (Node Version Manager)](https://github.com/creationix/nvm) to use the\n  `Node 6`.\n\n\n## Start contributing\n\n### 1. Fork the repo:\n\nGo to [carbon-components](https://github.com/IBM/carbon-components) and click\nthe `Fork` button in the top-right corner.\n\n### 2. Clone your fork:\n\n1.  Go to your [GitHub Repositories](https://github.com/settings/repositories).\n1.  Click on `[your_github_username]/carbon-components`.\n1.  Click on the `Clone or Download` button and copy the URL from the\n    `Clone with SSH` option. It should start with `git@github.com...`\n\nIn your terminal:\n\n```sh\ngit clone git@github.com:[your_github_username]/carbon-components.git\ncd carbon-components\n```\n\nSee [GitHub docs](https://help.github.com/articles/fork-a-repo/) for more\ndetails.\n\n### 3. Add upstream remotes\n\nWhen you clone your forked repo, doing a `git remote -v` will show that the\n`origin` remote is set up for you already by default. This should be pointing to\nyour forked repo.\n\nAdd the `IBM/carbon-components` repo to your remote (this can be useful to\nupdate your fork of new changes down the road):\n\n```sh\n# Add the upstream remote to your repo\ngit remote add upstream git@github.com:IBM/carbon-components.git\n\n# Verify the remote was added\ngit remote -v\n```\n\nWhen you do `git remote -v`, you'll see these remotes:\n\n- `origin`: connection to your fork\n- `upstream`: connection to the original repo.\n\n### 4. Work in a branch\n\n- Always work in a branch.\n- Submit pull requests from a branch.\n- All commits must follow the convention outlined\n  [here](https://github.com/conventional-changelog/conventional-changelog/blob/v0.5.3/conventions/angular.md).\n\n### 5. Start the server\n\n```sh\nnpm run dev\n\n# or\n\nyarn dev\n```\n\nOnce it's done building, you can start editing source code or creating new\ncomponents. The system is set up to automatically bundle your changes/additions.\nVisit http://localhost:3000 to see the changes happen on the fly.\n\nOptions:\n\n- `-b`: Enable breaking changes for the next release\n- `-e`: Enable experimental features\n\n### 6. Test your JavaScript code\n\nIf you're contributing to our JavaScript code, test your changes by running our\ntest commands:\n\n```sh\ngulp test:unit\n```\n\nIf you add any features to our JavaScript code, make sure to add tests so that\nyour code is covered. Tests are written in\n[Mocha](https://mochajs.org)/[Chai](http://chaijs.com). You can see if your code\nis covered by looking at carbon-components/tests/coverage/\\*/index.html after\nrunning test.\n\nIf your change may hit some browser quirks, use `-b` option, like:\n\n```sh\ngulp test:unit -b IE -b Firefox\n```\n\n(Other browsers tests can run with are: `Safari`, `Chrome` and `ChromeHeadless`)\n\nIf you are very sure that your change affects a specific set of components, you\ncan use `-f` option, like:\n\n```sh\ngulp test:unit -f tests/spec/fab_spec.js\n```\n\nOther options for testing are:\n\n- `-d`/`--debug`: Stop generating code coverage report. Useful to debug your\n  code when running test.\n- `-k`/`--keepalive`: Keep running test runner even after test ends. Test will\n  restart running when you make changes to any test files or any files under\n  test.\n- `-v`/`--verbose`: Let Karma emit detailed log.\n\n### 7. Test your HTML/CSS code for a11y\n\nIf you're contributing to our HTML/CSS code, a11y compliance of your code should\nbe tested.\n\nTo do so, you can test your changes by running our test commands:\n\n```sh\ngulp test:a11y\n```\n\nIf you are very sure that your change affects a specific set of components, you\ncan use `--name` option, like:\n\n```sh\ngulp test:a11y --name dropdown\n```\n\nThe a11y test may report potential issues that should be handled in\napplication-level, not in carbon-components code. In such case, you can ignore\nthose issues by adding an item to `shouldIssueBeIgnoredForRule` table in\n[tests/a11y/global-ignore-aat-issues.js](https://github.com/IBM/carbon-components/blob/master/tests/a11y/global-ignore-aat-issues.js).\nThe table is keyed by something like `wcag20.tech.h59.linkValid` which helps\nidentifying what RPT rule to ignore. You can specify `true` to the value which\nignores all violations of the rule, or a function which takes the DOM element\nviolating the rule and returns `true` if such violation should be ignored.\n\n### 8. Make a pull request\n\n**Note:** Before you make a pull request,\n[search](https://github.com/IBM/carbon-components/issues) the issues to see if a\nsimilar issue has already been submitted. If a similar issue has been submitted,\nassign yourself or ask to be assigned to the issue by posting a comment. If the\nissue does not exist, create a new issue.\n\nWhen you're at a good stopping place and you're ready for feedback from other\ncontributors and maintainers, **push your commits to your fork**:\n\n#### Commit tip\n\n> **Writing commit messages**\n>\n> - `<type>` indicates the type of commit that's being made. This can be:\n>   `feat`, `fix`, `perf`, `docs`, `chore`, `style`, `refactor`\n> - `<scope>` The scope could be anything specifying place of the commit change\n>   or the thing(s) that changed.\n>\n> **Commit message format:**\n\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n\n_Do not submit pull requests from the `master` branch of your fork._\n\n```\ngit checkout -b { YOUR_BRANCH_NAME }\ngit add .\ngit commit -m \"fix(table): IE11 positioning error\" -m \"Fixes #34\"\n```\n\n- [Close a commit via commit message](https://help.github.com/articles/closing-issues-via-commit-messages/)\n\n```\ngit push origin { YOUR_BRANCH_NAME }\n```\n\nIn your browser, navigate to\n[IBM/carbon-components](https://github.com/IBM/carbon-components) and click the\nbutton that reads `Compare & pull request`\n\n> **Is it a Breaking Change?**\n\n> We want to respect semver. It's important to discern whether your pull request\n> contains breaking changes or not. Sometimes, renaming or removing things in\n> the code can result in breaking changes.\n\n> Here are some examples of breaking changes... changing, renaming or removing\n> any of the following:\n>\n> - HTML attributes\n> - Folders or Files\n> - Any SCSS `@mixin`, `$variable` or `function`\n> - Any JS `function` or `class`\n\n> We also practice **graceful deprecation** when something is slated to be\n> removed -- we mark it as deprecated in the current version and remove it in\n> the next major version.\n\nBefore you create a pull request, change the base branch depending on what kind\nof change you're submitting.\n\n- Pull requests with **non-breaking changes** like patches and minor updates use\n  the `master` as the base branch.\n- Pull requests with **breaking changes** use the latest `major version number`\n  branch as the base branch (i.e. `7.0.0` or whatever the next major version\n  is).\n\nWrite a title and description then click `Create pull request`\n\n- [How to write the perfect pull request](https://github.com/blog/1943-how-to-write-the-perfect-pull-request)\n\n### 9. Updating a pull request\n\nStay up to date with the activity in your pull request. Maintainers from the\nDesign System team will be reviewing your work and making comments, asking\nquestions and suggesting changes to be made before they merge your code.\n\n:tada: You no longer need to squash commits :tada:\n\nWhen you need to make a change, add, commit and push to your branch normally.\n\nOnce all revisions to your pull request are complete, someone from Design\nSystems will squash and merge your commits for you.\n","type":"Mdx","contentDigest":"77fc8547e1cab8a60a2bc8462ea472ef","counter":250,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Contributing"},"exports":{},"rawBody":"---\ntitle: Contributing\n---\n\n## IBM Garage for Cloud Developer Tools\n\n_IBM Garage for Cloud Developer Tools_  is an organized effort managed by IBM Cloud Garage to help development teams build and deliver cloud-native solutions deployed to IBM Cloud with IBM Kubernetes and Red Hat OpenShift Managed Service .\n\n### Developer assets\n\n_Developer Tools assets_ (aka assets) are guidelines, components, and tooling, the result of community contributions of code, design, ideas, and guidance, that have been packaged and shared for reuse on development projects. Their purpose is twofold:\n- Increase the productivity of application developers\n- Increase the consistency of applications that are developed\n- Drive adoption of Kubernetes and OpenShift usage\n\nAssets will embody best practices for common application architectures, implementations, and development tasks and make those best practices easier to apply. Assets will be managed and made available for use via projects.\n\n###  Projects\n\n_Developer Tools projects_ (aka projects) are open source efforts narrowly focused on specific areas of interest. The assets are divided into projects. A project should organize a set of related assets such that a user or contributor interested in a project should be interested in  all of the assets in a project.\n\nEach project will store its assets in a GitHub repository to facilitate managing development of the assets as well as helping individual development projects to access and apply the assets.\n\n## Roles and responsibilities\n\n### Consumers\n\n_Consumers_ are members of the community who are applying assets to their development projects. Anyone who wants to apply any of the assets can be a user. We encourage consumers to participate as evangelists and contributors as well.\n\n### Evangelists\n\n_Evangelists_ are members of the community who help others become consumers of the assets. They do so by:\n- Advertising the assets and encouraging others to use them\n- Supporting new consumers and answering questions, such as on Slack (IBM internal)\n- Reporting bugs or missing features through GitHub issues\n\n### Contributors\n\n_Contributors_ are members of the community who help maintain, improve, and expand the assets. In addition to using and evangelizing the assets, they make the assets better by:\n- Resolving issues in GitHub to fix bugs, add features, and improve documentation\n- Submitting changes as GitHub pull requests\n\n### Maintainers\n\n_Project maintainers_ (aka maintainers) are owners of the project who are committed to the success of the assets in that project. Each project has a team of maintainers, and each team has a lead. In addition to their participation as contributors, maintainers have privileges to:\n- Label, close, and manage GitHub issues\n- Close and merge GitHub pull requests\n- Nominate and vote on new maintainers\n\n## Types of teams\n\n### Core team\n\nCore team members are IBM employees responsible for the leadership and strategic direction of the set of Catalyst projects as a whole. The core team also directs how the Catalyst strategy will evolve with IBM Cloud product decisions. Core team responsibilities include:\n\n- Actively engaging with the projects' communities\n- Setting overall direction and vision\n- Setting priorities and release schedule\n- Focusing on broad, cross-cutting concerns\n- Spinning up or shutting down project teams\n\nThe core team will operate the technical steering committee.\n\n#### Technical steering committee\n\nThe technical steering committee coordinates the project teams to ensure consistency between the projects and fosters collaboration between the core team and each project team. This close communication on cross-cutting concerns greatly mitigates the risk of misalignment that can come from decentralized efforts. The committee consists of the project leads of all of the projects as well as other members of the core team who may not presently be leading any projects.\n\n### Project teams\n\nEach project team maintains the assets in its project. Therefore, its members are the maintainers of the assets. Each project operates independently, though it should follow this governance structure to define roles, responsibilities, and decision-making protocols.\n\nThe project has a project lead, a lead maintainer who should also be a member of the [technical steering committee](#technical-steering-committee).\n\nEach project lead is responsible for:\n- Acting as a point of primary contact for the team\n- Participating in the technical steering committee\n- Deciding on the initial membership of project maintainers (in consultation with the core team)\n- Determining and publishing project team policies and mechanics, including the way maintainers join and leave the team (which should be based on team consensus)\n- Communicating core vision to the team\n- Ensuring that issues and pull requests progress at a reasonable rate\n- Making final decisions in cases where the team is unable to reach consensus (should be rare)\n\nThe way that project teams communicate internally and externally is left to each team, but:\n- Technical discussion should take place in the public domain as much as possible, ideally in GitHub issues and pull requests.\n- Each project should have a dedicated Slack channel (IBM internal). Decisions from Slack discussions should be captured in GitHub issues.\n- Project teams should actively seek out discussion and input from stakeholders who are not members of the team.\n\n## Governance\n\n### Planning\n\nProject planning is managed in a [Kanban board](https://en.wikipedia.org/wiki/Kanban_board), specifically this Zenhub board:\n\n- [Planning Zenhub](https://github.ibm.com/garage-catalyst/planning) (To Be Moved Externally)\n\n### Decision-making\n\nProject teams should use [consensus decision making](#consensus) as much as possible, but resort to [lack of consensus decision making](#lack-of-consensus) when necessary.\n\n#### Consensus\n\nProject teams use [consensus decision-making](http://en.wikipedia.org/wiki/Consensus_decision-making) with the premise that a successful outcome is not where one side of a debate has \"won,\" but rather where concerns from _all_ sides have been addressed in some way. **This emphatically does not mean design by committee, nor compromised design.** Rather, it's a recognition that every design or implementation choice carries a trade-off and numerous costs. There is seldom a 100% right answer.\n\nBreakthrough thinking sometimes end up changing the playing field by eliminating tradeoffs altogether, but more often, difficult decisions have to be made. **The key is to have a clear vision and set of values and priorities**, which is the core team's responsibility to set and communicate, and the project teams' responsibility to act upon.\n\nWhenever possible, seek to reach consensus through discussion and design iteration. Concretely, the steps are:\n\n- New GitHub issue or pull request is created with initial analysis of tradeoffs.\n- Comments reveal additional drawbacks, problems, or tradeoffs.\n- The issue or pull request is revised to address comments, often by improving the design or implementation.\n- Repeat above until \"major objections\" are fully addressed, or it's clear that there is a fundamental choice to be made.\n\nConsensus is reached when most people are left with only \"minor\" objections. While they might choose the tradeoffs slightly differently, they do not feel a strong need to _actively block_ the issue or pull request from progressing.\n\nOne important question is: consensus among which people, exactly? Of course, the broader the consensus, the better. When a decision in a project team affects other teams (e.g. new/changed API), the team will be encouraged to invite people (e.g. leads) from affected teams. But at the very least, **consensus within the members of the project team should be the norm for most decisions**. If the core team has done its job of communicating the values and priorities, it should be possible to fit the debate about the issue into that framework and reach a fairly clear outcome.\n\n#### Lack of consensus\n\nIn some cases, though, consensus cannot be reached. These cases tend to split into two very different camps:\n\n- **\"Trivial\" reasons**, e.g., there is not widespread agreement about naming, but there is consensus about the substance.\n- **\"Deep\" reasons**, e.g., the design fundamentally improves one set of concerns at the expense of another, and people on both sides feel strongly about it.\n\nIn either case, an alternative form of decision-making is needed.\n\n- For the \"trivial\" case, the project lead will make an executive decision or defer the decision to another maintainer on the team.\n- For the \"deep\" case, the project lead is empowered to make a final decision, but should consult with the core team before doing so.\n\n### Contribution process\n\nCatalyst assets are typically stored in GitHub repositories and use a [fork and pull request](https://guides.github.com/activities/forking/) workflow for contributions. Specific instructions can be found in each project's GitHub `CONTRIBUTING.md` file.\n\n### Contributor License Agreement\n\nWe require contributors outside of IBM to sign our Contributor License Agreement (CLA) before code contributions can be reviewed and merged. If you have questions, please [contact the core team](/help/support#email).\n\n### Support\n\nHave questions? Found a bug? Learn where to go and what to do by visiting the [Support page](/help/support).\n\n## Contributing\n\n## Requirements\n\nSet up your SSH Key GitHub account and install node.js 4 or higher.\n\n- [Generating SSH Keys - GitHub](https://help.github.com/articles/generating-ssh-keys/)\n- [`nvm` (Node Version Manager)](https://github.com/creationix/nvm) to use the\n  `Node 6`.\n\n\n## Start contributing\n\n### 1. Fork the repo:\n\nGo to [carbon-components](https://github.com/IBM/carbon-components) and click\nthe `Fork` button in the top-right corner.\n\n### 2. Clone your fork:\n\n1.  Go to your [GitHub Repositories](https://github.com/settings/repositories).\n1.  Click on `[your_github_username]/carbon-components`.\n1.  Click on the `Clone or Download` button and copy the URL from the\n    `Clone with SSH` option. It should start with `git@github.com...`\n\nIn your terminal:\n\n```sh\ngit clone git@github.com:[your_github_username]/carbon-components.git\ncd carbon-components\n```\n\nSee [GitHub docs](https://help.github.com/articles/fork-a-repo/) for more\ndetails.\n\n### 3. Add upstream remotes\n\nWhen you clone your forked repo, doing a `git remote -v` will show that the\n`origin` remote is set up for you already by default. This should be pointing to\nyour forked repo.\n\nAdd the `IBM/carbon-components` repo to your remote (this can be useful to\nupdate your fork of new changes down the road):\n\n```sh\n# Add the upstream remote to your repo\ngit remote add upstream git@github.com:IBM/carbon-components.git\n\n# Verify the remote was added\ngit remote -v\n```\n\nWhen you do `git remote -v`, you'll see these remotes:\n\n- `origin`: connection to your fork\n- `upstream`: connection to the original repo.\n\n### 4. Work in a branch\n\n- Always work in a branch.\n- Submit pull requests from a branch.\n- All commits must follow the convention outlined\n  [here](https://github.com/conventional-changelog/conventional-changelog/blob/v0.5.3/conventions/angular.md).\n\n### 5. Start the server\n\n```sh\nnpm run dev\n\n# or\n\nyarn dev\n```\n\nOnce it's done building, you can start editing source code or creating new\ncomponents. The system is set up to automatically bundle your changes/additions.\nVisit http://localhost:3000 to see the changes happen on the fly.\n\nOptions:\n\n- `-b`: Enable breaking changes for the next release\n- `-e`: Enable experimental features\n\n### 6. Test your JavaScript code\n\nIf you're contributing to our JavaScript code, test your changes by running our\ntest commands:\n\n```sh\ngulp test:unit\n```\n\nIf you add any features to our JavaScript code, make sure to add tests so that\nyour code is covered. Tests are written in\n[Mocha](https://mochajs.org)/[Chai](http://chaijs.com). You can see if your code\nis covered by looking at carbon-components/tests/coverage/\\*/index.html after\nrunning test.\n\nIf your change may hit some browser quirks, use `-b` option, like:\n\n```sh\ngulp test:unit -b IE -b Firefox\n```\n\n(Other browsers tests can run with are: `Safari`, `Chrome` and `ChromeHeadless`)\n\nIf you are very sure that your change affects a specific set of components, you\ncan use `-f` option, like:\n\n```sh\ngulp test:unit -f tests/spec/fab_spec.js\n```\n\nOther options for testing are:\n\n- `-d`/`--debug`: Stop generating code coverage report. Useful to debug your\n  code when running test.\n- `-k`/`--keepalive`: Keep running test runner even after test ends. Test will\n  restart running when you make changes to any test files or any files under\n  test.\n- `-v`/`--verbose`: Let Karma emit detailed log.\n\n### 7. Test your HTML/CSS code for a11y\n\nIf you're contributing to our HTML/CSS code, a11y compliance of your code should\nbe tested.\n\nTo do so, you can test your changes by running our test commands:\n\n```sh\ngulp test:a11y\n```\n\nIf you are very sure that your change affects a specific set of components, you\ncan use `--name` option, like:\n\n```sh\ngulp test:a11y --name dropdown\n```\n\nThe a11y test may report potential issues that should be handled in\napplication-level, not in carbon-components code. In such case, you can ignore\nthose issues by adding an item to `shouldIssueBeIgnoredForRule` table in\n[tests/a11y/global-ignore-aat-issues.js](https://github.com/IBM/carbon-components/blob/master/tests/a11y/global-ignore-aat-issues.js).\nThe table is keyed by something like `wcag20.tech.h59.linkValid` which helps\nidentifying what RPT rule to ignore. You can specify `true` to the value which\nignores all violations of the rule, or a function which takes the DOM element\nviolating the rule and returns `true` if such violation should be ignored.\n\n### 8. Make a pull request\n\n**Note:** Before you make a pull request,\n[search](https://github.com/IBM/carbon-components/issues) the issues to see if a\nsimilar issue has already been submitted. If a similar issue has been submitted,\nassign yourself or ask to be assigned to the issue by posting a comment. If the\nissue does not exist, create a new issue.\n\nWhen you're at a good stopping place and you're ready for feedback from other\ncontributors and maintainers, **push your commits to your fork**:\n\n#### Commit tip\n\n> **Writing commit messages**\n>\n> - `<type>` indicates the type of commit that's being made. This can be:\n>   `feat`, `fix`, `perf`, `docs`, `chore`, `style`, `refactor`\n> - `<scope>` The scope could be anything specifying place of the commit change\n>   or the thing(s) that changed.\n>\n> **Commit message format:**\n\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n\n_Do not submit pull requests from the `master` branch of your fork._\n\n```\ngit checkout -b { YOUR_BRANCH_NAME }\ngit add .\ngit commit -m \"fix(table): IE11 positioning error\" -m \"Fixes #34\"\n```\n\n- [Close a commit via commit message](https://help.github.com/articles/closing-issues-via-commit-messages/)\n\n```\ngit push origin { YOUR_BRANCH_NAME }\n```\n\nIn your browser, navigate to\n[IBM/carbon-components](https://github.com/IBM/carbon-components) and click the\nbutton that reads `Compare & pull request`\n\n> **Is it a Breaking Change?**\n\n> We want to respect semver. It's important to discern whether your pull request\n> contains breaking changes or not. Sometimes, renaming or removing things in\n> the code can result in breaking changes.\n\n> Here are some examples of breaking changes... changing, renaming or removing\n> any of the following:\n>\n> - HTML attributes\n> - Folders or Files\n> - Any SCSS `@mixin`, `$variable` or `function`\n> - Any JS `function` or `class`\n\n> We also practice **graceful deprecation** when something is slated to be\n> removed -- we mark it as deprecated in the current version and remove it in\n> the next major version.\n\nBefore you create a pull request, change the base branch depending on what kind\nof change you're submitting.\n\n- Pull requests with **non-breaking changes** like patches and minor updates use\n  the `master` as the base branch.\n- Pull requests with **breaking changes** use the latest `major version number`\n  branch as the base branch (i.e. `7.0.0` or whatever the next major version\n  is).\n\nWrite a title and description then click `Create pull request`\n\n- [How to write the perfect pull request](https://github.com/blog/1943-how-to-write-the-perfect-pull-request)\n\n### 9. Updating a pull request\n\nStay up to date with the activity in your pull request. Maintainers from the\nDesign System team will be reviewing your work and making comments, asking\nquestions and suggesting changes to be made before they merge your code.\n\n:tada: You no longer need to squash commits :tada:\n\nWhen you need to make a change, add, commit and push to your branch normally.\n\nOnce all revisions to your pull request are complete, someone from Design\nSystems will squash and merge your commits for you.\n","fileAbsolutePath":"/Users/seansund/ws/catalyst/garage-developer-guide/src/pages/contributing/index.mdx"}}}}